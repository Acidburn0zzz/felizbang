#!/bin/bash

# The FelizBang installation scripts for Openbox Arch Linux
# May 2016

# /common/shared - Variables and functions used by both sqiff and cliff

# Developed by Elizabeth Mills, incorporating some code adapted from
# the Evo/Lution script by Carl Duff and AUI scripts by HelmuthDU.

# Please read the introduction in the README file

#
# Partition variables and arrays
#
declare -a AddPartList    # Array of additional partitions eg: /dev/sda5
declare -a AddPartMount   # Array of mountpoints for the same partitions eg: /home
declare -a AddPartType    # Array of format type for the same partitions eg: ext4
declare -a PartitionArray # Array of long identifiers
declare -a NewArray       # For copying any array
declare -A LabellingArray # Associative array of user labels for partitions
declare -A Labelled       # Associative array of labelled partitions
declare -A FileSystem     # Associative array of filesystem types (ext* swap)
SwapPartition=""  # eg: /dev/sda3
FormatSwap="N"    # User selects whether to reuse swap
MakeSwap="Y"
SwapFile=""       # eg: 2G
IsSwap=""         # Result of lsblk test
RootPartition=""  # eg: /dev/sda2
RootType=""       # eg: ext4
Partition=""      # eg: sda1
AutoPart=0        # Flag - changes to 1 if auto-partition is chosen
UseDisk="sda"     # Used if more than one disk
DiskDetails=0     # Size of selected disk
#
# Grub, kernel & EFI variables
#
GrubDevice=""     # eg: /dev/sda
Kernel="1"        # Default 1 = LTS
IsInVbox=""       # Result of test to see if installation is in Virtualbox
DualBoot="N"      # Ready for dual-booting option
EFIPartition=""   # Will hold EFI partition mountpoint in format "/dev/sda1"
OSprober="Y"
#
# Location variables
#
CountryCode=""    # eg: GB ... for mirrorlist
CountryLocale=""  # eg: en_GB.UTF-8
Countrykbd=""     # eg: uk
ZONE=""           # eg: Europe For time
SUBZONE=""        # eg: London
#
# Root and user variables
#
HostName=""  # eg: arch-linux
UserName=""  # eg: archie
Scope="Full" # Installation scope ... hangover from Feliz
#
# Global user input variables
#
Response=""
Result=""

# --------------------------
# Functions             Line
# --------------------------
# ReflectorMirrorList     73
# LocalMirrorList         83
# Partitioning     from   98
# Review Stage     from  327
# Install Stage    from  371
# --------------------------

ReflectorMirrorList() { # Use reflector (added to archiso) to generate fast mirror list
  TPecho "Generating mirrorlist"
  reflector --verbose -l 5 --sort rate --save /etc/pacman.d/mirrorlist &>> feliz.log
  if [ $? -gt 0 ]; then
    LocalMirrorList
  else
    chmod +r /etc/pacman.d/mirrorlist &>> feliz.log
  fi
}

LocalMirrorList() { # In case Reflector fails, generate and save a shortened
  # mirrorlist of only the mirrors defined in the CountryCode variable.
  URL="https://www.archlinux.org/mirrorlist/?country=${CountryCode}&use_mirror_status=on"
  MirrorTemp=$(mktemp --suffix=-mirrorlist) &>> feliz.log
  # Use curl to get list of mirrors from the Arch mirrorlist ${URL} to ${MirrorTemp}
  curl -so ${MirrorTemp} ${URL} &>> feliz.log
  # Use sed to filter entries
  sed -i 's/^#Server/Server/g' ${MirrorTemp} &>> feliz.log
  # Make a safe copy of existing mirrorlist
  mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig &>> feliz.log
  # Replace existing mirrorlist with new local mirrorlist
  mv -f ${MirrorTemp} /etc/pacman.d/mirrorlist &>> feliz.log
  chmod +r /etc/pacman.d/mirrorlist &>> feliz.log
}

Parted() {
  parted --script /dev/${UseDisk} "$1" &>> feliz.log
}

MakePartitionList() {
  # Call BuildPartitionLists function to generate an array of partitions
  # This is not a first call, so first empty the existing array
  local x=0
  local HowMany="${#PartitionArray[@]}"
  until [ ${x} -eq ${HowMany} ]
  do
    unset PartitionArray[$x]
    x=$((x+1))
  done
  BuildPartitionLists # Then rebuild
}

BuildPartitionLists() { # First called by CheckParts to generate details of partitions
  # for display, then by feliz to prepare partition arrays for selection for root, swap and others
  # 1) First get a list of all partitions up to sda99 | select first field | remove /dev/ | remove colon
  ListTypeIDs=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $1}' | cut -c 6- | sed s/://g`
  # Then get matching list of types, removing unwanted text (TYPE=) and quotes
  ListTypes=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $(NF-1)}' | cut -c 6- | sed s/\"//g`
  # Add records from those two indexed arrays into the associative array
  local Counter=0
  for i in ${ListTypeIDs}
  do
    x=0
    for l in ${ListTypes}
    do
      if [ $x -eq $Counter ]; then
        FileSystem[$i]=$l # ... get the matching type
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  # 2) Find all up to sd*99 with LABEL | select 1st field | remove /dev/ | remove colon
  ListLabelledIDs=`sudo blkid /dev/sd* | grep LABEL | awk '{print $1}' | cut -c 6- | sed s/://g`
  # If at least one labelled partition found, get a matching list of labels (remove quotes)
  if [ -n "$ListLabelledIDs" ]; then
    ListLabelledLabels=`sudo blkid /dev/sd* | grep LABEL | awk '{print $2}' | cut -c 7- | sed s/\"//g`
  fi
  # Add records from those two indexed arrays into associative array
  Counter=0
  for i in ${ListLabelledIDs}
  do
    x=0
    for l in ${ListLabelledLabels}
    do
      if [ $x -eq $Counter ]; then
        Labelled[$i]=$l # ... get the matching label
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  local HowManyLabelled="${#Labelled[@]}"
  # 3) Find any partitions flagged as bootable
  ListAll=`sudo sfdisk -l | grep /dev | grep '*' | awk '{print $1}' | cut -c 6-`
  declare -a Flagged
  Counter=0
  for i in $ListAll
  do
    Flagged[${Counter}]="$i"
    Counter=$((Counter+1))
  done
  local HowManyFlagged="${#Flagged[@]}"
  # 4) Prepare list of short identifiers (sda1 sda2 ...)
  PartitionList=""
  ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  # 5) Run through short identifiers, checking the three arrays for a match
  Counter=0 # For count of partitions
  Label=""
  for part in ${ShowPartitions}
  do
  # First test Flagged
    local x=0
    until [ ${x} -eq ${HowManyFlagged} ]
    do
      if [ $part = "${Flagged[$x]}" ]; then
        Bootable="(Bootable)"
        break
      else
        Bootable=""
      fi
      x=$((x+1))
    done
    # Next test Labelled
    ThisPart=${Labelled[${part}]} # Find the record in Labelled that matches the current iteration
    if [ -n "${ThisPart}" ]; then
      Label="${ThisPart}"
    fi
    # Finally get the filesystem type
    ThisPart=${FileSystem[${part}]} # Find the record in FileSystem that matches the current iteration
    LongID=`lsblk -l | grep ${part} | awk '{print $1 " " $4 " " $7}'`
    PartitionArray[${Counter}]="$LongID $ThisPart ${Label} ${Bootable}"
    Label=""
    # Save the short ID for later functions
    PartitionList="${PartitionList} ${part}"
    (( Counter+=1 ))
  done
  PARTITIONS=${Counter}
}

UpdateArray() { # Remove the selected partition from $PartitionArray[]
  # Called by AllocateRoot, AllocateSwap and MorePartitions
  local Counter=0
  declare -a NewArray  # Empty NewArray
  # Build NewArray excluding the partition selected in the calling function
  for p in "${PartitionArray[@]}"
  do
    First=`echo $p | cut -c 1-5`
    if [ $First ]; then
      if [ ${PassPart} != ${First} ]; then
        NewArray[${Counter}]="$p"
        (( Counter+=1 ))
      fi
    fi
  done
  # Then copy NewArray into PartitionArray
  Counter=0
  for p in "${NewArray[@]}"
  do
    PartitionArray[${Counter}]=${NewArray[$Counter]}
    Counter=$((Counter+1))
  done
  unset PartitionArray[$Counter] # Delete the last element
}

RunAutoPart() {
  GrubDevice="/dev/${UseDisk}"
  Home="N"
  # Get disk size
  DiskSize=`lsblk -l | grep "${UseDisk}\ " | awk '{print $4}' | sed s/G//g`
  # Create partitions and set variables for mounting
  Parted "mklabel msdos"
  if [ $DiskSize -ge 40 ]; then
    # Device is large enough for a separate /home partition and larger
    # /root (20 GiB) and /swap (8 GiB)
    Parted "mkpart primary linux-swap 1MiB 8GiB"
    SwapPartition="${GrubDevice}1"
    MakeSwap="Y"
    # Root partition 15GiB
    Parted "mkpart primary ext4 8GiB 28GiB"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"
    # Home partition = remainder (size from 19GiB to maximum available)
    Parted "mkpart primary ext4 28GiB 100%"
    AddPartList[0]="${GrubDevice}3" # Add to the array of additional partitions
    AddPartMount[0]="/home"
    AddPartType[0]="ext4"
    Home="Y"
  elif [ $DiskSize -ge 30 ]; then
    # Device is just large enough for a separate /home partition
    # Swap 4GiB
    Parted "mkpart primary linux-swap 1MiB 4GiB"
    SwapPartition="${GrubDevice}1"
    MakeSwap="Y"
    # Root partition 15GiB
    Parted "mkpart primary ext4 4GiB 19GiB"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"
    # Home partition = remainder (size from 19GiB to maximum available)
    Parted "mkpart primary ext4 19GiB 100%"
    AddPartList[0]="${GrubDevice}3" # Add to the array of additional partitions
    AddPartMount[0]="/home"
    AddPartType[0]="ext4"
    Home="Y"
  elif [ $DiskSize -ge 18 ]; then
    # Swap 4Gib and one main partition up to 20GiB
    Parted "mkpart primary linux-swap 1MiB 4GiB"
    SwapPartition="${GrubDevice}1"
    MakeSwap="Y"
    Parted "mkpart primary ext4 4GiB 100%"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"
  elif [ $DiskSize -gt 10 ]; then
    # Swap 2Gib and one main partition up to 16GiB
    Parted "mkpart primary linux-swap 1MiB 2GiB"
    SwapPartition="${GrubDevice}1"
    Parted "mkpart primary ext4 2GiB 100%"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"
    SwapFile="2G"
    SwapPartition=""
  else # If disk < 10 Gb
    # Swap file and one main partition up to 10GiB
    Parted "mkpart primary ext4 1MiB 100%"
    Parted "set 1 boot on"
    RootPartition="${GrubDevice}1"
    RootType="ext4"
    SwapFile="2G"
    SwapPartition=""
  fi
  ShowPart1="Swap: `lsblk -l | grep "${UseDisk}1" | awk '{print $4}'`" >/dev/null
  ShowPart2="Root: `lsblk -l | grep "${UseDisk}2" | awk '{print $4}'`" >/dev/null
  ShowPart3=""
  AutoPart=1 # Set flag to 'on' for mounting
}

SetLabel() { # Called from the root, swap and extra partitions routines
# ... each passing a single argument containing the partition ID
# Build an associative array of partitions (LabellingArray[]) as
# declared in felizrunning with other arrays
PartitionID=$1
local HowMany="${#PartitionArray[@]}"
local x=0
until [ ${x} -eq ${HowMany} ]
do
  CompareID=`echo ${PartitionArray[${x}]} | awk '{print $1}'`
  if [ -z ${CompareID} ]; then
    x=$((x+1))
    continue
  fi
  if [ ${CompareID} = ${PartitionID} ]; then # If the partition is in the array, it has a label
  #  Label=`echo ${PartitionArray[${x}]} | awk '{print $4}'` # Save the label
  Label=`echo ${PartitionArray[${x}]}`
  fi
  x=$((x+1))
done
}

#
# Review stage ---------------------------------------------------------
#

ChangeRootPartition() {
# Start array with SwapPartition
  Ignorelist[0]=${SwapPartition}
  local Counter=1
  AddExtras
  MakePartitionList
}

ChangeSwapPartition() {
# Start array with RootPartition
  Ignorelist[0]=${RootPartition}
  Counter=1
  AddExtras
  MakePartitionList
}

ChangePartitions() {
  # Copy RootPartition and SwapPartition into temporary array
  Ignorelist[0]=${RootPartition}
  local Counter=1
  if [ ${SwapPartition} ]; then
    Ignorelist[1]=${SwapPartition}
    Counter=2
  fi
  Ignores=${#Ignorelist[@]} # Save a count for later
  MakePartitionList
}

AddExtras() {
  # Called by ChangeSwapPartition and ChangeRootPartition with
  # Ignorelist started and Counter set to next record number
  # Add each field (extra partition) from AddPartList into the array:
  for a in ${AddPartList[@]}; do
    Ignorelist[$Counter]=$a
    Counter=$((Counter+1))
  done
  Ignores=${#Ignorelist[@]} # Save a count for later
}

#
# Install stage --------------------------------------------------------
#

InstallLuxuries() { # Install Openbox and extras
  # Test for existing display manager and disable if necessary
  arch-chroot /mnt touch etc/output.log      # Create empty file
  arch-chroot /mnt systemctl list-unit-files | grep 'lightdm.service' > mnt/etc/output.log
  DMLine=`cat /mnt/etc/output.log`
  local Counter=1
  case ${DMLine} in
    "") echo "No previous DM discovered" >> feliz.log
    ;;
    *) local Continue="Y"
      while [ ${Continue} = "Y" ]
      do
        ExDM=`echo $DMLine  | cut -f ${Counter} -d ' '` # First of pair is DM
        if [ -z ${ExDM} ]; then
          Continue="N" # Quit if no further entries
          break
        fi
        Counter=$((Counter+1))
        ExDMStatus=`echo $DMLine  | cut -f ${Counter} -d ' '` # Second is status
        case ${ExDMStatus} in
          "enabled") arch_chroot "systemctl disable ${ExDM}" >/dev/null
          ;;
          *) echo "${ExDM} already disabled" >> feliz.log
        esac
        Counter=$((Counter+1))
      done
  esac
  # Then install LightDM
  TPecho "Installing LightDM" ""
  pacstrap /mnt lightdm lightdm-deepin-greeter &>> feliz.log
  arch_chroot "systemctl -f enable lightdm.service" >/dev/null
  DisplayProgress "Installing 'Openbox' window manager" 20
  pacstrap /mnt openbox obmenu obconf compton tint2 &>> feliz.log

  # add list of applications here .................................................................
  pacstrap /mnt abiword epiphany galculator gnome-mahjongg gnumeric leafpad lxterminal &>> feliz.log
  pacstrap /mnt nitrogen pavucontrol pcmanfm scrot sol xfce4-screenshooter &>> feliz.log

  TPecho "Modifying pacman.conf and installing Yaourt"
  cp pacman.conf /mnt/etc 2>> feliz.log # For installed system
  cp pacman.conf /etc 2>> feliz.log # For installer
  pacman-key --init &>> feliz.log
  pacman-key --populate archlinux &>> feliz.log
  pacman -Sy &>> feliz.log # Update
  pacstrap /mnt yaourt &>> feliz.log
  TPecho "Installing Conky"
  pacstrap /mnt conky &>> feliz.log
}

UserAdd() {
  CheckUsers=`cat /mnt/etc/passwd | grep ${UserName}`
  # If not already exist, create user
  if [ -z ${CheckUsers} ]; then
    TPecho "Adding user '${UserName}' and setting up groups"
    arch_chroot "useradd ${UserName} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/bash"
    # Set up basic configuration files and permissions for user
    arch_chroot "cp /etc/skel/.bashrc /home/${UserName}"
    arch_chroot "chown -R ${UserName}:users /home/${UserName}"
    sed -i '/%wheel ALL=(ALL) ALL/s/^#//' /mnt/etc/sudoers 2>> feliz.log
  else
    TPecho "User already exists"
  fi
}
